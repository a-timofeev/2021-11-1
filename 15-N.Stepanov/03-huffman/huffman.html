<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>ü§î</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300&display=swap" rel="stylesheet">
    <!--link rel="stylesheet" href="../shared/style/stylesheet.css"-->
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://d3js.org/d3.v7.js"></script>
</head>
<body>

<div id="root" :class="{secondary: !encodeMode}" class="accent-bg">
    <app-header class="shadow">–ê–ª–≥–æ—Ä–∏—Ç–º –•–∞—Ñ—Ñ–º–∞–Ω–∞</app-header>

    <app-main class="shadow" back="..">

        <div class="center">
            <ui-button :secondary="!encodeMode" :on-click="switchMode" id="mode-switcher" class="shadow">
                <span v-if="encodeMode">–†–µ–∂–∏–º –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è</span>
                <span v-else>–†–µ–∂–∏–º –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è</span>
            </ui-button>
        </div>

        <div class="spaced-out3 flex">
            <ui-textarea
                    id="input-main"
                    class="shadow accent-bg"
                    dynamic-resize
                    @input="updateInput"
                    ref="textarea"
            >

            </ui-textarea>
        </div>

        <div class="spaced-out3 shadow accent-bg rounded" id="algorithm-result">
            <div v-if="this.encodeMode">
                <div class="algorithm-result-content">
                    <div>
                        {{this.encodedBuffer?.toHex()}}
                    </div>
                </div>
                <div class="center spaced-out2 copy-buttons">
                    <button-group>
                        <ui-button :on-click="() => this.copyResult('bin')">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å Binary</ui-button>
                        <ui-button :on-click="() => this.copyResult('hex')">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å Hex</ui-button>
                        <ui-button :on-click="() => this.copyResult('base64')">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å Base64</ui-button>
                    </button-group>
                </div>
            </div>
            <div v-else>
                <div class="algorithm-result-content">
                    <div v-if="this.errorDescription !== undefined" class="error">
                        <div v-if="this.errorDescription === 'unknown-format'">
                            –≠—Ç–æ—Ç —Ñ–æ—Ä–º–∞—Ç –Ω–µ –∏–∑–≤–µ—Å—Ç–µ–Ω. –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ –≤—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–ª–∏ –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç?
                        </div>
                        <div v-else-if="this.errorDescription === 'unsupported-version'">
                            –≠—Ç–∞ –≤–µ—Ä—Å–∏—è —Ñ–æ—Ä–º–∞—Ç–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è
                        </div>
                        <div v-else>
                            –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {{this.errorDescription}}
                        </div>
                    </div>
                    <div v-else>
                        ok
                    </div>
                </div>
            </div>
        </div>

        <frequency-chart
                :frequencies="this.frequencies"
                class="shadow accent-bg rounded"
                :secondary="!encodeMode"
                id="frequency-chart"
        >
        </frequency-chart>

        <huffman-tree-chart
                :tree="this.tree"
                class="shadow accent-bg rounded spaced-out3"
                :secondary="!encodeMode"
                id="huffman-tree-chart"
        >

        </huffman-tree-chart>

        <ui-snackbar ref="snackbar" :type="snackbarType"></ui-snackbar>

    </app-main>
    <app-footer class="shadow"></app-footer>
</div>

<script type="module">
    import {buildHuffmanTree, dictionaryFromTree} from "./huffman-algorithm.js"
    import BinaryBuffer from "./binary-buffer.js"
    import BinaryScanner from "./binary-scanner.js"
    import {copyToClipboard} from "./clipboard.js"

    const formatCode = 0x25485546

    import("../shared/components/all.js")
        .then(() => import("./local-components.js"))
        .then(_ => new Vue({
            el: "#root",

            data: () => ({
                encodeMode: true,
                input: "",
                frequencies: [],
                tree: undefined,
                encodedBuffer: undefined,
                binaryInputScanner: undefined,
                errorDescription: undefined,
                snackbarType: "success",
            }),

            methods: {
                switchMode() {
                    this.encodeMode = !this.encodeMode
                    // if (this.encodeMode) {
                    //     this.binaryInputScanner = undefined
                    // } else {
                    //     this.encodedBuffer = undefined
                    // }
                },

                updateInput(e) {
                    this.input = e.target.innerText
                },

                onInputUpdate() {
                    console.log("update")
                    console.log(this.input)
                    if (this.encodeMode) {
                        this.updateFrequencies(this.input)
                    } else {
                        if (this.input.startsWith("JUh")) {
                            this.binaryInputScanner = BinaryScanner.fromBase64(this.input)
                        } else if (this.input.startsWith("25485546")) {
                            this.binaryInputScanner = BinaryScanner.fromHex(this.input)
                        } else if (this.input.startsWith("00100101010010000101010101000110")) {
                            this.binaryInputScanner = BinaryScanner.fromBin(this.input)
                        }
                        if (!this.binaryInputScanner || this.binaryInputScanner.nextInt() !== formatCode) {
                            this.binaryInputScanner = undefined
                            this.errorDescription = "unknown-format"
                        }
                    }
                },

                updateFrequencies(input) {
                    const counter = {}
                    for (const c of input) {
                        counter[c] = (counter[c] || 0) + 1
                    }
                    const frequencies = []
                    for (let c in counter) {
                        frequencies.push({c: c, frequency: counter[c]})
                    }
                    this.frequencies = frequencies
                },

                updateTree(frequencies) {
                    this.tree = buildHuffmanTree(frequencies)
                },

                encode(tree, input, frequencies) {
                    const buffer = new BinaryBuffer()

                    buffer.pushInt(formatCode)  // stands for %HUF
                    buffer.pushInt(1)  // Version
                    buffer.pushInt(frequencies.length)

                    for (const {c, frequency} of frequencies) {
                        buffer.pushChar(c)
                        buffer.pushInt(frequency)
                    }

                    buffer.pushInt(input.length)

                    const dict = dictionaryFromTree(tree)

                    for (const c of input) {
                        buffer.pushBinary(dict[c].binary, dict[c].size)
                    }

                    this.encodedBuffer = buffer
                },

                copyResult(type) {
                    const callback = ({success, error}) => {
                        if (success) {
                            this.$refs.snackbar.appear("üìå –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!")
                            this.snackbarType = "success"
                        } else if (error === "unsupported") {
                            this.$refs.snackbar.appear("ü§î –ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ, –∏–∑–≤–∏–Ω–∏—Ç–µ üò¢")
                            this.snackbarType = "error"
                        } else {
                            this.$refs.snackbar.appear(`üò≤ –û—à–∏–±–∫–∞: ${error}`)
                            this.snackbarType = "error"
                        }
                    }

                    if (type === "text") {
                        copyToClipboard(this.input, callback)
                    } else if (type === "bin") {
                        copyToClipboard(this.encodedBuffer.toBin(), callback)
                    } else if (type === "hex") {
                        copyToClipboard(this.encodedBuffer.toHex(), callback)
                    } else if (type === "base64") {
                        copyToClipboard(this.encodedBuffer.toBase64(), callback)
                    } else {
                        console.error(`Unknown result type: ${type}`)
                    }
                },
            },

            created() {
                this.encode(undefined, "", "")
            },

            watch: {
                // TODO: generate those hard-coded strings from formatCode
                input() {
                    this.onInputUpdate()
                },

                encodeMode() {
                    if (this.encodeMode) {
                        this.input = "" // TODO: temporary solution
                    } else {
                        this.input = this.encodedBuffer.toHex()
                    }

                    this.$refs.textarea.innerText = this.input
                },

                frequencies() {
                    this.updateTree(this.frequencies)
                },

                tree() {
                    this.encode(this.tree, this.input, this.frequencies)
                    console.log(this.encodedBuffer)
                },
            }
        })).catch(e => console.error(e))
</script>

</body>
</html>
