<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>ü§î</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300&display=swap" rel="stylesheet">
    <!--link rel="stylesheet" href="../shared/style/stylesheet.css"-->
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://d3js.org/d3.v7.js"></script>
</head>
<body>

<div id="root" :class="{secondary: !encodeMode}" class="accent-bg">
    <app-header class="shadow">–ê–ª–≥–æ—Ä–∏—Ç–º –•–∞—Ñ—Ñ–º–∞–Ω–∞</app-header>

    <app-main class="shadow" back="..">

        <div class="center">
            <ui-button :secondary="!encodeMode" :on-click="switchMode" id="mode-switcher" class="shadow">
                <span v-if="encodeMode">–†–µ–∂–∏–º –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è</span>
                <span v-else>–†–µ–∂–∏–º –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è</span>
            </ui-button>
        </div>

        <div class="spaced-out3 flex">
            <ui-textarea
                    id="input-main"
                    class="shadow accent-bg"
                    dynamic-resize
                    @input="updateInput"
                    ref="textarea"
            >
            </ui-textarea>
        </div>

        <div class="spaced-out3 shadow accent-bg rounded" id="algorithm-result">
            <div id="algorithm-result-content">
                <div>
                    {{this.encodedBuffer?.toHex()}}
                </div>
            </div>
            <div class="center spaced-out2 copy-buttons">
                <button-group>
                    <ui-button :on-click="() => this.copyResult('bin')">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å Binary</ui-button>
                    <ui-button :on-click="() => this.copyResult('hex')">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å Hex</ui-button>
                    <ui-button :on-click="() => this.copyResult('base64')">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å Base64</ui-button>
                </button-group>
            </div>
        </div>

        <frequency-chart
                :frequencies="this.frequencies"
                class="shadow accent-bg rounded"
                :secondary="!encodeMode"
                id="frequency-chart"
        >
        </frequency-chart>

        <huffman-tree-chart
                :tree="this.tree"
                class="shadow accent-bg rounded spaced-out3"
                :secondary="!encodeMode"
                id="huffman-tree-chart"
        >

        </huffman-tree-chart>

        <ui-snackbar ref="snackbar"></ui-snackbar>

    </app-main>
    <app-footer class="shadow"></app-footer>
</div>

<script type="module">
    import {buildHuffmanTree, dictionaryFromTree} from "./huffman-algorithm.js"
    import BinaryBuffer from "./binary-buffer.js"
    import {copyToClipboard} from "./clipboard.js"

    import("../shared/components/all.js")
        .then(() => import("./local-components.js"))
        .then(_ => new Vue({
            el: "#root",

            data: () => ({
                encodeMode: true,
                input: "",
                frequencies: [],
                tree: undefined,
                encodedBuffer: undefined,
            }),

            methods: {
                switchMode() {
                    this.encodeMode = !this.encodeMode
                },

                updateInput(e) {
                    this.input = e.target.innerText
                },

                updateFrequencies(input) {
                    const counter = {}
                    for (const c of input) {
                        counter[c] = (counter[c] || 0) + 1
                    }
                    const frequencies = []
                    for (let c in counter) {
                        frequencies.push({c: c, frequency: counter[c]})
                    }
                    this.frequencies = frequencies
                },

                updateTree(frequencies) {
                    this.tree = buildHuffmanTree(frequencies)
                },

                encode(tree, input, frequencies) {
                    const buffer = new BinaryBuffer()

                    buffer.pushBinary(0x25485546, 32)  // stands for %HUFF
                    buffer.pushInt(1)  // Version
                    buffer.pushInt(frequencies.length)

                    for (const {c, frequency} of frequencies) {
                        buffer.pushChar(c)
                        buffer.pushInt(frequency)
                    }

                    buffer.pushInt(input.length)

                    const dict = dictionaryFromTree(tree)

                    for (const c of input) {
                        buffer.pushBinary(dict[c].binary, dict[c].size)
                    }

                    this.encodedBuffer = buffer
                },

                copyResult(type) {
                    const callback = ({success, error}) => {
                        if (success) {
                            this.$refs.snackbar.appear("üìå –°–∫–æ–ø –∏—Ä–æ–≤–∞–Ω–æ!")
                        } else if (error === "unsupported") {
                            this.$refs.snackbar.appear("ü§î –ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ, –∏–∑–≤–∏–Ω–∏—Ç–µ üò¢")
                        } else {
                            this.$refs.snackbar.appear(`üò≤ –û—à–∏–±–∫–∞: ${error}`)
                        }
                        console.log(success, error)
                    }

                    if (type === "text") {
                        copyToClipboard(this.input, callback)
                    } else if (type === "bin") {
                        copyToClipboard(this.encodedBuffer.toBin(), callback)
                    } else if (type === "hex") {
                        copyToClipboard(this.encodedBuffer.toHex(), callback)
                    } else if (type === "base64") {
                        copyToClipboard(this.encodedBuffer.toBase64(), callback)
                    } else {
                        console.error(`Unknown result type: ${type}`)
                    }
                }
            },

            created() {
                this.encode(undefined, "", "")
            },

            watch: {
                input() {
                    this.updateFrequencies(this.input)
                },

                frequencies() {
                    this.updateTree(this.frequencies)
                },

                tree() {
                    this.encode(this.tree, this.input, this.frequencies)
                },
            }
        })).catch(e => console.error(e))
</script>

</body>
</html>
